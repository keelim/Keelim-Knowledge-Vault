Flow[[Flow]] 에서도 비슷한 연산자를 사용하고 있음으로 같이 연관있게 보면 좋다.다른 데이터를 다루는 곳에서도 동일하거나 비슷한 개념을 사용하고 있으니 참고하면 좋다. 
- collection [[Collection]]
- sequence [[Sequence]]
- kotlin stdlib [[Kotlin stdlib]]

## 필터
- filter
	- filterNot
	- filterIndexed
	- filterTo
	- filterNotTo
	- filterindexedto
	- filterNotNull
	- filterNotNullTo
## 조건 검색
- all
- any
- none
- first
	- first
	- firstorNull
- last
	- last
	- lastOrNull
- single
- find
	- find
	- findLast
- count
- index
	- indexOf
	- indexFirst
	- indexOfLast
- element
	- elementAt
	- elementAtorElse
	- elementAtorNull
## 변환
- map
	- map
	- mapIndexed
	- mapTo
	- mapindexedTo
	- mapNotNull
	- mapIndexedNotNull
	- mapIndexedNotNullTo
- flatMap
	- flatMap
	- flatMapIndexed
	- flatMapTo
	- flatMpaIndexedOf
	- flatMpaIndexedTo
- flatten
## 부분
- take
	- take
	- takewWhile
	- takeLast
	- takeLastWhile
- drop
	- drop
	- dropWhile
	- dropLast
	- dropLastWhile
- slice
## 값 찾기
- fold
	- fold
	- foldIndexed
	- runningFold
	- runningFoldIndexed
	- foldRight
	- foldRightIndexed
- scan
	- scan
	- scanIndexed
- reduce
	- reduce
	- reduceIndexed
	- reduceOrNull
	- reduceIndexedOrNull
	- scanReduce
	- scanReduceIndexed
	- runningReduce
	- runningReduceIndexed
	- reduceRight
	- reduceRightIndexed
	- reduceRightOrNull
	- reduceRightOrNullIndexed
- random
	- random
	- randomOrNull
## 그룹화
- zip
	- zip
	- zipWithNext
- groupBy
- associate
	- associate
	- associateBy
	- associateWith
	- associateTo
	- associateByTo
	- associateWithTo
- windowed
- chunk
- set
	- intersect
	- subtract
	- union
	- distinct
	- ditinctBy
	- plus
	- minus
- partition
- joinToString
## 정렬
- sort
	- sort
	- sortBy
	- sortByDecending
	- wortWith
	- sorted
	- sortedBy
	- sortedByDecending
	- sortedWith
- reversed
- shuffle
## toCollection
- toCollection
- toList
- toSet
- toMutableList
- toMutableSet
- toHashSet
- toByteArray
- toShortArray
- toIntArray
- toLongArray
- toCharArray
- toFloatArray
- toDoubleArray

---
- buffer
	- **중간에 큐(queue)를 추가**하는 역할을 합니다. 만약 생산자(producer)는 빠른데 소비자(consumer)가 느리다면, 생산자를 일시 중단(suspend)시키는 대신, 방출(emit)된 값들을 버퍼 큐에 쌓아둡니다.
```kotlin
suspend fun consume() {
    produceFaster()
        .buffer() // 버퍼 추가
        .collect {
            delay(1000) // 소비가 1초 걸림
            println("Collected $it")
        }
}

fun produceFaster(): Flow<Int> = flow {
    for (i in 1..5) {
        emit(i)
        println("Emitted $i") // 생산은 바로바로 됨
    }
}
```
여기서 만약 `buffer`를 사용하지 않으면, `emit()` 호출은 `collect` 블록의 처리가 끝날 때까지 일시 중단. 하지만 `buffer`를 사용하면 `emit()`은 멈추지 않고, 값들을 버퍼에 저장해두었다가 `collect`가 나중에 처리하게 됩니다.

**이럴 때 사용하세요:** **생산자가 멈추는(blocked) 것을 원치 않을 때** 유용합니다. 예를 들어 데이터 스트리밍이나 사용자 입력 처리 같은 경우에 적합.

- conflate 
	- 이 연산자는 **가장 최신 값만 전달**합니다. 즉, 소비자가 너무 느려서 처리하지 못하는 중간 값들은 모두 건너뛰고 가장 마지막 값만 전달합니다.

```kotlin
flow {
    emit(1)
    delay(100)
    emit(2)
    delay(100)
    emit(3)
    delay(100)
    emit(4)
}
.conflate() // 중간 값(2, 3)을 합쳐서 최신 값(4)만 전달
.collect {
    println("Start Collecting $it")
    delay(300) // 느린 소비자
    println("Done Collecting $it")
}
```
예제에서 볼 수 있듯이, 첫 번째 값 `1`을 처리하는 데 300ms가 걸리는 동안 `2`, `3`, `4`가 방출되었습니다. `conflate`는 중간 값들을 건너뛰고 가장 최신 값인 `4`만 전달합니다.

**이럴 때 사용하세요:** **중간 상태는 신경 쓰지 않고 실시간 UI 업데이트**를 보여줄 때 유용합니다. 예를 들면 **진행률 표시줄(progress bar), 실시간 차트, '입력 중' 표시** 같은 기능에 쓸 수 있습니다.

- collectLatest
	- `conflate`와 비슷하게 **가장 최근에 방출된 값을 처리**합니다.

```kotlin
flow {
    emit(1)
    delay(100)
    emit(2)
    delay(100)
    emit(3)
}
.collectLatest { // 새로운 값이 오면 이전 작업을 취소
    println("Start Collecting $it")
    delay(200) // 느린 소비자
    println("Done Collecting $it")
}
```


`conflate`의 출력 결과를 보면 각 값에 대해 'start collecting'과 'done collecting' 로그가 모두 찍힙니다. 하지만 `collectLatest`의 경우, 마지막으로 방출된 값에 대해서만 'done collecting'이 찍힙니다. 이는 `collectLatest`가 **새로운 값이 방출되면 진행 중이던 이전 `collect` 블록의 작업을 취소**하고 새로운 값으로 작업을 다시 시작하기 때문입니다.

`collectLatest`는 값 처리에 시간이 걸리지만 **가장 최신 결과만 중요할 때** 유용합니다. 반면 `conflate`는 일단 시작된 작업은 중간에 취소하지 않고 끝까지 처리합니다. 모든 값을 처리할 필요는 없지만, **일단 시작한 작업은 낭비하고 싶지 않을 때** 이상적입니다.

**이럴 때 사용하세요:** **검색, 슬라이더, 타이핑**과 같이 UI 입력이 빠르게 변할 때, **가장 마지막 작업의 결과만 필요할 때** 사용합니다.

- sample
	- **일정한 시간 간격으로 가장 최신 값을 방출**합니다.

```kotlin
flow {
    repeat(10) {
        emit(it)
        delay(100)
    }
}
.sample(300) // 300ms 간격으로 최신 값을 샘플링
.collect {
    println("Collected $it")
}
```

`debounce`와 `sample`이 헷갈릴 수 있는데, 중요한 차이점이 있습니다.

`debounce`는 **'활동이 없는 시간'**을 기준으로 동작합니다. 예를 들어 검색창에 글자를 입력하다가 잠시 멈추면, 그 멈춘 시간이 `debounce`에 설정한 시간과 일치할 때 마지막 값을 방출합니다.

반면 `sample`은 사용자가 입력을 멈췄는지 여부와 상관없이, **무조건 정해진 시간 간격마다** 그 시점의 최신 값을 방출합니다.

**이럴 때 사용하세요:** **차트 업데이트, 하드웨어 센서 값 폴링(polling), 고정된 주기로 화면을 갱신**해야 하는 UI에 적합합니다.