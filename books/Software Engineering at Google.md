## 소프트웨어 엔지니어링이란?  
### 시간과 변경  
### 규모 확장과 효율성  
### 트레이드오프와 비용  
### 소프트웨어 엔지니어링 vs 프로그래밍  
  
## 팀워크이끌어내기
### 내 코드를 숨기고 싶어요  
### 천재 신화  
### 숨기는 건 해롭다  
### 모든 건 팀에 달렸다  
  
## 지식 공유  
### 배움을 가로막는 장애물  
### 철학  
### 판 깔아주기: 심리적 안전  
### 내 지식 키우기  
### 질문 확장하기: 커뮤니티에 묻기  
### 지식 확장하기: 누구나 가르칠 게 있다  
### 조직의 지식 확장하기  
### 가독성 제도: 코드 리뷰를 통한 표준 멘토 제도  
  
## 공정 사회를 위한 엔지니어링  
### 편견은 피할 수 없다  
### 다양성이 필요한 이유 이해하기  
### 다문화 역량 갖추기  
### 다양성 실천하기  
### 단일한 접근 방식 거부하기  
### 확립된 프로세스에 도전하기  
### 가치 vs 결과  
### 관심을 잃지 말고 전진하자  
  
## 팀 이끌기  
### 관리자와 테크 리드(혹은 둘 다)  
### 개인 기여자에서 리더로  
### 엔지니어링 관리자  
### 안티패턴  
### 올바른 패턴  
### 예상 못한 질문  
### 그 외 조언과 요령  
### 사람은 식물과 같다  
  
## 성장하는 조직 이끌기  
### 늘 결정하라(Always Be Deciding)  
### 늘 떠나라(Always Be Leaving)  
### 늘 확장하라(Always Be Scaling)  
  
## 엔지니어링 생산성 측정하기  
### 엔지니어링 생산성을 측정하는 이유  
### 선별: 측정할 가치가 있는가?  
### GSM 프레임워크: 목표와 신호를 뒷받침하는 의미 있는 지표 선정하기  
### 목표(goal)  
### 신호(signal)  
### 지표(metric)  
### 데이터로 지표 검증하기  
### 조치를 취하고 결과 추적하기  
  
## 스타일 가이드와 규칙  
### 규칙이 필요한 이유  
### 규칙 만들기  
### 규칙 수정하기  
### 지침  
### 규칙 적용하기  
  
## 코드 리뷰  [[code review]]
### 코드 리뷰 흐름  
### 코드 리뷰 @ 구글  
### 코드 리뷰의 이점  
### 코드 리뷰 모범 사례  
### 코드 리뷰 유형  
  
## 문서자료  
### 문서자료란?  
### 문서자료가 필요한 이유  
### 문서자료는 코드와 같다  
### 독자를 알라  
### 문서자료 유형  
### 문서자료 리뷰  
### 문서화 철학  
### 테크니컬 라이터가 필요한 순간  
  
## 테스트 개요  [[TDD]]
### 테스트를 작성하는 이유  
### 테스트 스위트 설계하기  
### 구글 규모의 테스트  
### 구글의 테스트 역사  
### 자동 테스트의 한계  
  
## 단위 테스트  [[unit test]]
### 유지보수하기 쉬워야 한다  
### 깨지기 쉬운 테스트 예방하기  
### 명확한 테스트 작성하기  
### 테스트와 코드 공유: DRY가 아니라 DAMP!  
  
## 테스트 대역  
### 테스트 대역이 소프트웨어 개발에 미치는 영향  
### 테스트 대역 @ 구글  
### 기본 개념  
### 테스트 대역 활용 기법  
### 실제 구현  
### 속이기(가짜 객체)  
### 뭉개기(스텁)  
### 상호작용 테스트하기  
  
## 더 큰 테스트  
### 더 큰 테스트란?  
### 더 큰 테스트 @ 구글  
### 큰 테스트의 구조  
###  더 큰 테스트 유형  
### 큰 테스트와 개발자 워크플로  
  
## 폐기  
### 폐기시키는 이유  
### 폐기는 왜 그리 어려운가?  
### 폐기 유형  
### 폐기 프로세스 관리  
  

## 버전 관리와 브랜치 관리  
### 버전 관리란?  
### 브랜치 관리  
### 버전 관리 @ 구글  
### 모노리포(단일 리포지터리)  
### 버전 관리의 미래  
  
## Code Search  
###  Code Search UI  
### 구글 개발자가 Code Search를 이용하는 방법  
### 독립된 웹 도구로 만든 이유  
### 규모가 설계에 미치는 영향  
### 구글은 어떻게 구현했나?  
### 구글이 선택한 트레이드오프  
  
## 빌드 시스템과 빌드 철학  [[Gradle]]
### 빌드 시스템의 목적  
### 빌드 시스템이 없다면?  
### 모던 빌드 시스템  
### 모듈과 의존성 다루기  
  
## Critique: 구글의 코드 리뷰 도구  
### 코드 리뷰 도구 원칙  
### 코드 리뷰 흐름  
### 1단계: 변경 생성  
### 2단계: 리뷰 요청  
### 3~4단계: 변경 이해하고 댓글 달기  
### 5단계: 변경 승인(변경에 점수 매기기)  
### 6단계: 변경 커밋  
  
## 정적 분석  
### 효과적인 정적 분석의 특징  
### 정적 분석을 적용하며 깨우친 핵심 교훈  
### Tricorder: 구글의 정적 분석 플랫폼  
  
## 의존성 관리  
### 의존성 관리가 어려운 이유  
### 의존성 임포트하기  
### (이론상의) 의존성 관리  
### 유의적 버전의 한계  
### 자원이 무한할 때의 의존성 관리  
  
## 대규모 변경  
### 대규모 변경이란?  
### 누가 대규모 변경을 처리하나?  
### 원자적 변경을 가로막는 요인  
### 대규모 변경 인프라  
### 대규모 변경 프로세스  
  
## 지속적 통합  
### 지속적 통합이란?  
### 지속적 통합 @ 구글  
  
## 지속적 배포  
### 지속적 배포 이디엄 @ 구글  
### 속도는 팀 스포츠다: 배포를 관리 가능한 조각으로 나누기  
### 변경을 격리해 평가하자: 기능 플래그로 보호하기  
### 기민해지기 위한 분투: 릴리스 열차 갖추기  
### 품질과 사용자에 집중: 사용할 기능만 배포하자  
### 원점 회귀: 데이터에 기초해 더 일찍 결정하자  
### 팀 문화 바꾸기: 배포 규율 세우기  
  
## 서비스형 컴퓨트  
### 컴퓨트 환경 길들이기  
### 관리형 컴퓨트에 적합한 소프트웨어 작성하기  
### 시간과 규모에 따른 CaaS  
### 컴퓨트 서비스 선택하기  