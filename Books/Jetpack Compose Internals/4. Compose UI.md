- LayoutNode
- 여러개 Composition 이 있을 수 있다. 
- LayoutNode
	- Layout Composable
```kotlin
inline fun Layout(  
    content: @Composable @UiComposable () -> Unit,  
    modifier: Modifier = Modifier,  
    measurePolicy: MeasurePolicy  
) {  
    val compositeKeyHash = currentCompositeKeyHash  
    val localMap = currentComposer.currentCompositionLocalMap  
    val materialized = currentComposer.materialize(modifier)  
    ReusableComposeNode<ComposeUiNode, Applier<Any>>(  
        factory = ComposeUiNode.Constructor,  
        update = {  
            set(measurePolicy, SetMeasurePolicy)  
            set(localMap, SetResolvedCompositionLocals)  
            @OptIn(ExperimentalComposeUiApi::class)  
            set(compositeKeyHash, SetCompositeKeyHash)  
            set(materialized, SetModifier)  
        },  
        content = content  
    )  
}
```
- ​SubComposition, SubComposeLayout
	하위 Composable 변화를 상위 Composable 이 알 수 있도록
	- 초기 composition 과정에서 특정 정보를 알 때까지 연기하기 위해
	-  하위 트리에서 생성되는 노드의 타입을 변경하기 위해


Subcomposition 은 부 모 Composition 과 독 립 적 으 로 recompose 할 수 있 게 해 줍 니 다.
SubcomposeLayout을 예시로 들어보면, 레이아웃 단계가 발생할 때 마다 SubcomposeLayout의
람 다 에 전 달 되 는 매 개 변 수 가 변 할 수 있 으 며, 이 는 recomposition 을 유 발 합 니 다. 반 면 에
Subcomposition에서 읽은 state가 변경되면, 초기 composition이 수행된 후 부모 Composition
에 대한 recomposition이 예약됩니다.

```kotlin
fun rememberVectorPainter(  
    defaultWidth: Dp,  
    defaultHeight: Dp,  
    viewportWidth: Float = Float.NaN,  
    viewportHeight: Float = Float.NaN,  
    name: String = RootGroupName,  
    tintColor: Color = Color.Unspecified,  
    tintBlendMode: BlendMode = BlendMode.SrcIn,  
    autoMirror: Boolean = false,  
    content: @Composable @VectorComposable (viewportWidth: Float, viewportHeight: Float) -> Unit  
): VectorPainter {  
    val density = LocalDensity.current  
    val defaultSize = density.obtainSizePx(defaultWidth, defaultHeight)  
    val viewport = obtainViewportSize(defaultSize, viewportWidth, viewportHeight)  
    val intrinsicColorFilter = remember(tintColor, tintBlendMode) {  
        createColorFilter(tintColor, tintBlendMode)  
    }  
    return remember { VectorPainter() }.apply {  
        configureVectorPainter(  
            defaultSize = defaultSize,  
            viewportSize = viewport,  
            name = name,  
            intrinsicColorFilter = intrinsicColorFilter,  
            autoMirror = autoMirror  
        )  
        val compositionContext = rememberCompositionContext()  
        this.composition = remember(viewportWidth, viewportHeight, content) {  
            val curComp = this.composition  
            val next = if (curComp == null || curComp.isDisposed) {  
                Composition(  
                    VectorApplier(this.vector.root),  
                    compositionContext  
                )  
            } else {  
                curComp  
            }  
            next.setContent {  
                content(viewport.width, viewport.height)  
            }  
            next  
        }  
    }}
```

```kotlin
@Composable  
@UiComposable  
fun SubcomposeLayout(  
    state: SubcomposeLayoutState,  
    modifier: Modifier = Modifier,  
    measurePolicy: SubcomposeMeasureScope.(Constraints) -> MeasureResult  
) {  
    val compositeKeyHash = currentCompositeKeyHash  
    val compositionContext = rememberCompositionContext()  
    val materialized = currentComposer.materialize(modifier)  
    val localMap = currentComposer.currentCompositionLocalMap  
    ReusableComposeNode<LayoutNode, Applier<Any>>(  
        factory = LayoutNode.Constructor,  
        update = {  
            set(state, state.setRoot)  
            set(compositionContext, state.setCompositionContext)  
            set(measurePolicy, state.setMeasurePolicy)  
            set(localMap, SetResolvedCompositionLocals)  
            set(materialized, SetModifier)  
            @OptIn(ExperimentalComposeUiApi::class)  
            set(compositeKeyHash, SetCompositeKeyHash)  
        }  
    )  
    if (!currentComposer.skipping) {  
        SideEffect {  
            state.forceRecomposeChildren()  
        }  
    }  
}
```

FlowRow, FlowColumn 은 또 SubComposeLayout 이 아니네..